// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package flyio

import (
	"context"
	"reflect"

	"errors"
	"github.com/lukeshay/pulumi-flyio/sdk/go/flyio/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Fly.io Postgres attachment connects a Postgres database to an application.
type PostgresAttachment struct {
	pulumi.CustomResourceState

	// The application to attach the Postgres database to.
	App pulumi.StringOutput `pulumi:"app"`
	// The unique ID of the Postgres attachment.
	AttachmentId pulumi.StringOutput `pulumi:"attachmentId"`
	// The PostgreSQL connection string.
	ConnectionString pulumi.StringOutput `pulumi:"connectionString"`
	// The name of the database to use.
	DatabaseName pulumi.StringPtrOutput `pulumi:"databaseName"`
	// The database user to connect as.
	DatabaseUser pulumi.StringPtrOutput `pulumi:"databaseUser"`
	// Whether to manually enter the connection details.
	ManualEntry pulumi.BoolPtrOutput `pulumi:"manualEntry"`
	// The Postgres cluster to attach.
	Postgres pulumi.StringOutput `pulumi:"postgres"`
	// The environment variable name that contains the connection string.
	VariableName pulumi.StringOutput `pulumi:"variableName"`
}

// NewPostgresAttachment registers a new resource with the given unique name, arguments, and options.
func NewPostgresAttachment(ctx *pulumi.Context,
	name string, args *PostgresAttachmentArgs, opts ...pulumi.ResourceOption) (*PostgresAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.App == nil {
		return nil, errors.New("invalid value for required argument 'App'")
	}
	if args.Postgres == nil {
		return nil, errors.New("invalid value for required argument 'Postgres'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"connectionString",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PostgresAttachment
	err := ctx.RegisterResource("flyio:index:PostgresAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPostgresAttachment gets an existing PostgresAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPostgresAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PostgresAttachmentState, opts ...pulumi.ResourceOption) (*PostgresAttachment, error) {
	var resource PostgresAttachment
	err := ctx.ReadResource("flyio:index:PostgresAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PostgresAttachment resources.
type postgresAttachmentState struct {
}

type PostgresAttachmentState struct {
}

func (PostgresAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*postgresAttachmentState)(nil)).Elem()
}

type postgresAttachmentArgs struct {
	// The application to attach the Postgres database to.
	App string `pulumi:"app"`
	// The name of the database to use.
	DatabaseName *string `pulumi:"databaseName"`
	// The database user to connect as.
	DatabaseUser *string `pulumi:"databaseUser"`
	// Whether to manually enter the connection details.
	ManualEntry *bool `pulumi:"manualEntry"`
	// The Postgres cluster to attach.
	Postgres string `pulumi:"postgres"`
	// The environment variable name to store the connection string.
	VariableName *string `pulumi:"variableName"`
}

// The set of arguments for constructing a PostgresAttachment resource.
type PostgresAttachmentArgs struct {
	// The application to attach the Postgres database to.
	App pulumi.StringInput
	// The name of the database to use.
	DatabaseName pulumi.StringPtrInput
	// The database user to connect as.
	DatabaseUser pulumi.StringPtrInput
	// Whether to manually enter the connection details.
	ManualEntry pulumi.BoolPtrInput
	// The Postgres cluster to attach.
	Postgres pulumi.StringInput
	// The environment variable name to store the connection string.
	VariableName pulumi.StringPtrInput
}

func (PostgresAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*postgresAttachmentArgs)(nil)).Elem()
}

type PostgresAttachmentInput interface {
	pulumi.Input

	ToPostgresAttachmentOutput() PostgresAttachmentOutput
	ToPostgresAttachmentOutputWithContext(ctx context.Context) PostgresAttachmentOutput
}

func (*PostgresAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**PostgresAttachment)(nil)).Elem()
}

func (i *PostgresAttachment) ToPostgresAttachmentOutput() PostgresAttachmentOutput {
	return i.ToPostgresAttachmentOutputWithContext(context.Background())
}

func (i *PostgresAttachment) ToPostgresAttachmentOutputWithContext(ctx context.Context) PostgresAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostgresAttachmentOutput)
}

// PostgresAttachmentArrayInput is an input type that accepts PostgresAttachmentArray and PostgresAttachmentArrayOutput values.
// You can construct a concrete instance of `PostgresAttachmentArrayInput` via:
//
//	PostgresAttachmentArray{ PostgresAttachmentArgs{...} }
type PostgresAttachmentArrayInput interface {
	pulumi.Input

	ToPostgresAttachmentArrayOutput() PostgresAttachmentArrayOutput
	ToPostgresAttachmentArrayOutputWithContext(context.Context) PostgresAttachmentArrayOutput
}

type PostgresAttachmentArray []PostgresAttachmentInput

func (PostgresAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PostgresAttachment)(nil)).Elem()
}

func (i PostgresAttachmentArray) ToPostgresAttachmentArrayOutput() PostgresAttachmentArrayOutput {
	return i.ToPostgresAttachmentArrayOutputWithContext(context.Background())
}

func (i PostgresAttachmentArray) ToPostgresAttachmentArrayOutputWithContext(ctx context.Context) PostgresAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostgresAttachmentArrayOutput)
}

// PostgresAttachmentMapInput is an input type that accepts PostgresAttachmentMap and PostgresAttachmentMapOutput values.
// You can construct a concrete instance of `PostgresAttachmentMapInput` via:
//
//	PostgresAttachmentMap{ "key": PostgresAttachmentArgs{...} }
type PostgresAttachmentMapInput interface {
	pulumi.Input

	ToPostgresAttachmentMapOutput() PostgresAttachmentMapOutput
	ToPostgresAttachmentMapOutputWithContext(context.Context) PostgresAttachmentMapOutput
}

type PostgresAttachmentMap map[string]PostgresAttachmentInput

func (PostgresAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PostgresAttachment)(nil)).Elem()
}

func (i PostgresAttachmentMap) ToPostgresAttachmentMapOutput() PostgresAttachmentMapOutput {
	return i.ToPostgresAttachmentMapOutputWithContext(context.Background())
}

func (i PostgresAttachmentMap) ToPostgresAttachmentMapOutputWithContext(ctx context.Context) PostgresAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostgresAttachmentMapOutput)
}

type PostgresAttachmentOutput struct{ *pulumi.OutputState }

func (PostgresAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PostgresAttachment)(nil)).Elem()
}

func (o PostgresAttachmentOutput) ToPostgresAttachmentOutput() PostgresAttachmentOutput {
	return o
}

func (o PostgresAttachmentOutput) ToPostgresAttachmentOutputWithContext(ctx context.Context) PostgresAttachmentOutput {
	return o
}

// The application to attach the Postgres database to.
func (o PostgresAttachmentOutput) App() pulumi.StringOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringOutput { return v.App }).(pulumi.StringOutput)
}

// The unique ID of the Postgres attachment.
func (o PostgresAttachmentOutput) AttachmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringOutput { return v.AttachmentId }).(pulumi.StringOutput)
}

// The PostgreSQL connection string.
func (o PostgresAttachmentOutput) ConnectionString() pulumi.StringOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringOutput { return v.ConnectionString }).(pulumi.StringOutput)
}

// The name of the database to use.
func (o PostgresAttachmentOutput) DatabaseName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringPtrOutput { return v.DatabaseName }).(pulumi.StringPtrOutput)
}

// The database user to connect as.
func (o PostgresAttachmentOutput) DatabaseUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringPtrOutput { return v.DatabaseUser }).(pulumi.StringPtrOutput)
}

// Whether to manually enter the connection details.
func (o PostgresAttachmentOutput) ManualEntry() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.BoolPtrOutput { return v.ManualEntry }).(pulumi.BoolPtrOutput)
}

// The Postgres cluster to attach.
func (o PostgresAttachmentOutput) Postgres() pulumi.StringOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringOutput { return v.Postgres }).(pulumi.StringOutput)
}

// The environment variable name that contains the connection string.
func (o PostgresAttachmentOutput) VariableName() pulumi.StringOutput {
	return o.ApplyT(func(v *PostgresAttachment) pulumi.StringOutput { return v.VariableName }).(pulumi.StringOutput)
}

type PostgresAttachmentArrayOutput struct{ *pulumi.OutputState }

func (PostgresAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PostgresAttachment)(nil)).Elem()
}

func (o PostgresAttachmentArrayOutput) ToPostgresAttachmentArrayOutput() PostgresAttachmentArrayOutput {
	return o
}

func (o PostgresAttachmentArrayOutput) ToPostgresAttachmentArrayOutputWithContext(ctx context.Context) PostgresAttachmentArrayOutput {
	return o
}

func (o PostgresAttachmentArrayOutput) Index(i pulumi.IntInput) PostgresAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PostgresAttachment {
		return vs[0].([]*PostgresAttachment)[vs[1].(int)]
	}).(PostgresAttachmentOutput)
}

type PostgresAttachmentMapOutput struct{ *pulumi.OutputState }

func (PostgresAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PostgresAttachment)(nil)).Elem()
}

func (o PostgresAttachmentMapOutput) ToPostgresAttachmentMapOutput() PostgresAttachmentMapOutput {
	return o
}

func (o PostgresAttachmentMapOutput) ToPostgresAttachmentMapOutputWithContext(ctx context.Context) PostgresAttachmentMapOutput {
	return o
}

func (o PostgresAttachmentMapOutput) MapIndex(k pulumi.StringInput) PostgresAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PostgresAttachment {
		return vs[0].(map[string]*PostgresAttachment)[vs[1].(string)]
	}).(PostgresAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PostgresAttachmentInput)(nil)).Elem(), &PostgresAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*PostgresAttachmentArrayInput)(nil)).Elem(), PostgresAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PostgresAttachmentMapInput)(nil)).Elem(), PostgresAttachmentMap{})
	pulumi.RegisterOutputType(PostgresAttachmentOutput{})
	pulumi.RegisterOutputType(PostgresAttachmentArrayOutput{})
	pulumi.RegisterOutputType(PostgresAttachmentMapOutput{})
}

// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package flyio

import (
	"context"
	"reflect"

	"errors"
	"github.com/lukeshay/pulumi-flyio/sdk/go/flyio/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages application secrets for a Fly.io application.
type Secrets struct {
	pulumi.CustomResourceState

	// The Fly.io application the secrets are set for.
	App pulumi.StringOutput `pulumi:"app"`
	// The secret values, as key-value pairs.
	Values pulumi.StringMapOutput `pulumi:"values"`
}

// NewSecrets registers a new resource with the given unique name, arguments, and options.
func NewSecrets(ctx *pulumi.Context,
	name string, args *SecretsArgs, opts ...pulumi.ResourceOption) (*Secrets, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.App == nil {
		return nil, errors.New("invalid value for required argument 'App'")
	}
	if args.Values == nil {
		return nil, errors.New("invalid value for required argument 'Values'")
	}
	if args.Values != nil {
		args.Values = pulumi.ToSecret(args.Values).(pulumi.StringMapInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"values",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Secrets
	err := ctx.RegisterResource("flyio:index:Secrets", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSecrets gets an existing Secrets resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSecrets(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SecretsState, opts ...pulumi.ResourceOption) (*Secrets, error) {
	var resource Secrets
	err := ctx.ReadResource("flyio:index:Secrets", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Secrets resources.
type secretsState struct {
}

type SecretsState struct {
}

func (SecretsState) ElementType() reflect.Type {
	return reflect.TypeOf((*secretsState)(nil)).Elem()
}

type secretsArgs struct {
	// The Fly.io application to set secrets for.
	App string `pulumi:"app"`
	// The secret values to set, as key-value pairs.
	Values map[string]string `pulumi:"values"`
}

// The set of arguments for constructing a Secrets resource.
type SecretsArgs struct {
	// The Fly.io application to set secrets for.
	App pulumi.StringInput
	// The secret values to set, as key-value pairs.
	Values pulumi.StringMapInput
}

func (SecretsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*secretsArgs)(nil)).Elem()
}

type SecretsInput interface {
	pulumi.Input

	ToSecretsOutput() SecretsOutput
	ToSecretsOutputWithContext(ctx context.Context) SecretsOutput
}

func (*Secrets) ElementType() reflect.Type {
	return reflect.TypeOf((**Secrets)(nil)).Elem()
}

func (i *Secrets) ToSecretsOutput() SecretsOutput {
	return i.ToSecretsOutputWithContext(context.Background())
}

func (i *Secrets) ToSecretsOutputWithContext(ctx context.Context) SecretsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretsOutput)
}

// SecretsArrayInput is an input type that accepts SecretsArray and SecretsArrayOutput values.
// You can construct a concrete instance of `SecretsArrayInput` via:
//
//	SecretsArray{ SecretsArgs{...} }
type SecretsArrayInput interface {
	pulumi.Input

	ToSecretsArrayOutput() SecretsArrayOutput
	ToSecretsArrayOutputWithContext(context.Context) SecretsArrayOutput
}

type SecretsArray []SecretsInput

func (SecretsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Secrets)(nil)).Elem()
}

func (i SecretsArray) ToSecretsArrayOutput() SecretsArrayOutput {
	return i.ToSecretsArrayOutputWithContext(context.Background())
}

func (i SecretsArray) ToSecretsArrayOutputWithContext(ctx context.Context) SecretsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretsArrayOutput)
}

// SecretsMapInput is an input type that accepts SecretsMap and SecretsMapOutput values.
// You can construct a concrete instance of `SecretsMapInput` via:
//
//	SecretsMap{ "key": SecretsArgs{...} }
type SecretsMapInput interface {
	pulumi.Input

	ToSecretsMapOutput() SecretsMapOutput
	ToSecretsMapOutputWithContext(context.Context) SecretsMapOutput
}

type SecretsMap map[string]SecretsInput

func (SecretsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Secrets)(nil)).Elem()
}

func (i SecretsMap) ToSecretsMapOutput() SecretsMapOutput {
	return i.ToSecretsMapOutputWithContext(context.Background())
}

func (i SecretsMap) ToSecretsMapOutputWithContext(ctx context.Context) SecretsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretsMapOutput)
}

type SecretsOutput struct{ *pulumi.OutputState }

func (SecretsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Secrets)(nil)).Elem()
}

func (o SecretsOutput) ToSecretsOutput() SecretsOutput {
	return o
}

func (o SecretsOutput) ToSecretsOutputWithContext(ctx context.Context) SecretsOutput {
	return o
}

// The Fly.io application the secrets are set for.
func (o SecretsOutput) App() pulumi.StringOutput {
	return o.ApplyT(func(v *Secrets) pulumi.StringOutput { return v.App }).(pulumi.StringOutput)
}

// The secret values, as key-value pairs.
func (o SecretsOutput) Values() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Secrets) pulumi.StringMapOutput { return v.Values }).(pulumi.StringMapOutput)
}

type SecretsArrayOutput struct{ *pulumi.OutputState }

func (SecretsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Secrets)(nil)).Elem()
}

func (o SecretsArrayOutput) ToSecretsArrayOutput() SecretsArrayOutput {
	return o
}

func (o SecretsArrayOutput) ToSecretsArrayOutputWithContext(ctx context.Context) SecretsArrayOutput {
	return o
}

func (o SecretsArrayOutput) Index(i pulumi.IntInput) SecretsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Secrets {
		return vs[0].([]*Secrets)[vs[1].(int)]
	}).(SecretsOutput)
}

type SecretsMapOutput struct{ *pulumi.OutputState }

func (SecretsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Secrets)(nil)).Elem()
}

func (o SecretsMapOutput) ToSecretsMapOutput() SecretsMapOutput {
	return o
}

func (o SecretsMapOutput) ToSecretsMapOutputWithContext(ctx context.Context) SecretsMapOutput {
	return o
}

func (o SecretsMapOutput) MapIndex(k pulumi.StringInput) SecretsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Secrets {
		return vs[0].(map[string]*Secrets)[vs[1].(string)]
	}).(SecretsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SecretsInput)(nil)).Elem(), &Secrets{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretsArrayInput)(nil)).Elem(), SecretsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretsMapInput)(nil)).Elem(), SecretsMap{})
	pulumi.RegisterOutputType(SecretsOutput{})
	pulumi.RegisterOutputType(SecretsArrayOutput{})
	pulumi.RegisterOutputType(SecretsMapOutput{})
}

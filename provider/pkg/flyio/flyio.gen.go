// Package flyio provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package flyio

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for MachineHostStatus.
const (
	MachineHostStatusOk          MachineHostStatus = "ok"
	MachineHostStatusUnknown     MachineHostStatus = "unknown"
	MachineHostStatusUnreachable MachineHostStatus = "unreachable"
)

// Defines values for SignalRequestSignal.
const (
	SIGABRT SignalRequestSignal = "SIGABRT"
	SIGALRM SignalRequestSignal = "SIGALRM"
	SIGFPE  SignalRequestSignal = "SIGFPE"
	SIGHUP  SignalRequestSignal = "SIGHUP"
	SIGILL  SignalRequestSignal = "SIGILL"
	SIGINT  SignalRequestSignal = "SIGINT"
	SIGKILL SignalRequestSignal = "SIGKILL"
	SIGPIPE SignalRequestSignal = "SIGPIPE"
	SIGQUIT SignalRequestSignal = "SIGQUIT"
	SIGSEGV SignalRequestSignal = "SIGSEGV"
	SIGTERM SignalRequestSignal = "SIGTERM"
	SIGTRAP SignalRequestSignal = "SIGTRAP"
	SIGUSR1 SignalRequestSignal = "SIGUSR1"
)

// Defines values for VolumeHostStatus.
const (
	VolumeHostStatusOk          VolumeHostStatus = "ok"
	VolumeHostStatusUnknown     VolumeHostStatus = "unknown"
	VolumeHostStatusUnreachable VolumeHostStatus = "unreachable"
)

// Defines values for FlyEnvFromFieldRef.
const (
	AppName   FlyEnvFromFieldRef = "app_name"
	Id        FlyEnvFromFieldRef = "id"
	Image     FlyEnvFromFieldRef = "image"
	PrivateIp FlyEnvFromFieldRef = "private_ip"
	Region    FlyEnvFromFieldRef = "region"
	Version   FlyEnvFromFieldRef = "version"
)

// Defines values for FlyMachineCheckKind.
const (
	Informational FlyMachineCheckKind = "informational"
	Readiness     FlyMachineCheckKind = "readiness"
)

// Defines values for FlyMachineRestartPolicy.
const (
	Always    FlyMachineRestartPolicy = "always"
	No        FlyMachineRestartPolicy = "no"
	OnFailure FlyMachineRestartPolicy = "on-failure"
	SpotPrice FlyMachineRestartPolicy = "spot-price"
)

// Defines values for FlyMachineServiceAutostop.
const (
	Off     FlyMachineServiceAutostop = "off"
	Stop    FlyMachineServiceAutostop = "stop"
	Suspend FlyMachineServiceAutostop = "suspend"
)

// Defines values for MainStatusCode.
const (
	CapacityErr MainStatusCode = "insufficient_capacity"
	Unknown     MainStatusCode = "unknown"
)

// Defines values for MachinesWaitParamsState.
const (
	Destroyed MachinesWaitParamsState = "destroyed"
	Started   MachinesWaitParamsState = "started"
	Stopped   MachinesWaitParamsState = "stopped"
	Suspended MachinesWaitParamsState = "suspended"
)

// App defines model for App.
type App struct {
	Id           *string       `json:"id,omitempty" pulumi:"flyId"`
	Name         *string       `json:"name,omitempty" pulumi:"name"`
	Organization *Organization `json:"organization,omitempty" pulumi:"organization"`
	Status       *string       `json:"status,omitempty" pulumi:"status"`
}

// CheckStatus defines model for CheckStatus.
type CheckStatus struct {
	Name      *string `json:"name,omitempty" pulumi:"name,optional"`
	Output    *string `json:"output,omitempty" pulumi:"output,optional"`
	Status    *string `json:"status,omitempty" pulumi:"status,optional"`
	UpdatedAt *string `json:"updated_at,omitempty" pulumi:"updatedAt,optional"`
}

// CreateAppRequest defines model for CreateAppRequest.
type CreateAppRequest struct {
	AppName          *string `json:"app_name,omitempty" pulumi:"appName"`
	EnableSubdomains *bool   `json:"enable_subdomains,omitempty" pulumi:"enableSubdomains,optional"`
	Network          *string `json:"network,omitempty" pulumi:"network,optional"`
	OrgSlug          *string `json:"org_slug,omitempty" pulumi:"orgSlug"`
}

// CreateLeaseRequest defines model for CreateLeaseRequest.
type CreateLeaseRequest struct {
	Description *string `json:"description,omitempty" pulumi:"description,optional"`

	// Ttl seconds lease will be valid
	Ttl *int `json:"ttl,omitempty" pulumi:"ttl,optional"`
}

// CreateMachineRequest defines model for CreateMachineRequest.
type CreateMachineRequest struct {
	// Config An object defining the Machine configuration
	Config   *FlyMachineConfig `json:"config,omitempty" pulumi:"config"`
	LeaseTtl *int              `json:"lease_ttl,omitempty" pulumi:"leaseTtl,optional"`
	Lsvd     *bool             `json:"lsvd,omitempty" pulumi:"lsvd,optional"`

	// Name Unique name for this Machine. If omitted, one is generated for you
	Name *string `json:"name,omitempty" pulumi:"name,optional"`

	// Region The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).
	Region                  *string `json:"region,omitempty" pulumi:"region,optional"`
	SkipLaunch              *bool   `json:"skip_launch,omitempty" pulumi:"skipLaunch,optional"`
	SkipServiceRegistration *bool   `json:"skip_service_registration,omitempty" pulumi:"skipServiceRegistration,optional"`
}

// CreateOIDCTokenRequest Optional parameters
type CreateOIDCTokenRequest struct {
	Aud *string `json:"aud,omitempty" pulumi:"aud,optional"`
}

// CreateVolumeRequest defines model for CreateVolumeRequest.
type CreateVolumeRequest struct {
	Compute           *FlyMachineGuest `json:"compute,omitempty" pulumi:"compute,optional"`
	ComputeImage      *string          `json:"compute_image,omitempty" pulumi:"computeImage,optional"`
	Encrypted         *bool            `json:"encrypted,omitempty" pulumi:"encrypted,optional"`
	Fstype            *string          `json:"fstype,omitempty" pulumi:"fstype,optional"`
	Name              *string          `json:"name,omitempty" pulumi:"name,optional"`
	Region            *string          `json:"region,omitempty" pulumi:"region,optional"`
	RequireUniqueZone *bool            `json:"require_unique_zone,omitempty" pulumi:"requireUniqueZone,optional"`
	SizeGb            *int             `json:"size_gb,omitempty" pulumi:"sizeGb,optional"`

	// SnapshotId restore from snapshot
	SnapshotId        *string `json:"snapshot_id,omitempty" pulumi:"snapshotId,optional"`
	SnapshotRetention *int    `json:"snapshot_retention,omitempty" pulumi:"snapshotRetention,optional"`

	// SourceVolumeId fork from remote volume
	SourceVolumeId *string `json:"source_volume_id,omitempty" pulumi:"sourceVolumeId,optional"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Deprecated
	Details *map[string]interface{} `json:"details,omitempty" pulumi:"details,optional"`
	Error   *string                 `json:"error,omitempty" pulumi:"error,optional"`
	Status  *MainStatusCode         `json:"status,omitempty" pulumi:"status,optional"`
}

// ExtendVolumeRequest defines model for ExtendVolumeRequest.
type ExtendVolumeRequest struct {
	SizeGb *int `json:"size_gb,omitempty" pulumi:"sizeGb,optional"`
}

// ExtendVolumeResponse defines model for ExtendVolumeResponse.
type ExtendVolumeResponse struct {
	NeedsRestart *bool   `json:"needs_restart,omitempty" pulumi:"needsRestart,optional"`
	Volume       *Volume `json:"volume,omitempty" pulumi:"volume,optional"`
}

// ImageRef defines model for ImageRef.
type ImageRef struct {
	Digest     *string            `json:"digest,omitempty" pulumi:"digest,optional"`
	Labels     *map[string]string `json:"labels,omitempty" pulumi:"labels,optional"`
	Registry   *string            `json:"registry,omitempty" pulumi:"registry,optional"`
	Repository *string            `json:"repository,omitempty" pulumi:"repository,optional"`
	Tag        *string            `json:"tag,omitempty" pulumi:"tag,optional"`
}

// Lease defines model for Lease.
type Lease struct {
	// Description Description or reason for the Lease.
	Description *string `json:"description,omitempty" pulumi:"description,optional"`

	// ExpiresAt ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid.
	ExpiresAt *int `json:"expires_at,omitempty" pulumi:"expiresAt,optional"`

	// Nonce Nonce is the unique ID autogenerated and associated with the Lease.
	Nonce *string `json:"nonce,omitempty" pulumi:"nonce,optional"`

	// Owner Owner is the user identifier which acquired the Lease.
	Owner *string `json:"owner,omitempty" pulumi:"owner,optional"`

	// Version Machine version
	Version *string `json:"version,omitempty" pulumi:"version,optional"`
}

// ListApp defines model for ListApp.
type ListApp struct {
	Id           *string                 `json:"id,omitempty" pulumi:"flyId"`
	MachineCount *int                    `json:"machine_count,omitempty" pulumi:"machineCount,optional"`
	Name         *string                 `json:"name,omitempty" pulumi:"name,optional"`
	Network      *map[string]interface{} `json:"network,omitempty" pulumi:"network,optional"`
}

// ListAppsResponse defines model for ListAppsResponse.
type ListAppsResponse struct {
	Apps      *[]ListApp `json:"apps,omitempty" pulumi:"apps,optional"`
	TotalApps *int       `json:"total_apps,omitempty" pulumi:"totalApps,optional"`
}

// ListSecret defines model for ListSecret.
type ListSecret struct {
	Label     *string `json:"label,omitempty" pulumi:"label,optional"`
	Publickey *[]int  `json:"publickey,omitempty" pulumi:"publickey,optional"`
	Type      *string `json:"type,omitempty" pulumi:"type,optional"`
}

// ListenSocket defines model for ListenSocket.
type ListenSocket struct {
	Address *string `json:"address,omitempty" pulumi:"address,optional"`
	Proto   *string `json:"proto,omitempty" pulumi:"proto,optional"`
}

// Machine defines model for Machine.
type Machine struct {
	Checks           *[]CheckStatus     `json:"checks,omitempty" pulumi:"checks,optional"`
	Config           *FlyMachineConfig  `json:"config,omitempty" pulumi:"config"`
	CreatedAt        *string            `json:"created_at,omitempty" pulumi:"createdAt,optional"`
	Events           *[]MachineEvent    `json:"events,omitempty" pulumi:"events,optional"`
	HostStatus       *MachineHostStatus `json:"host_status,omitempty" pulumi:"hostStatus,optional"`
	Id               *string            `json:"id,omitempty" pulumi:"flyId"`
	ImageRef         *ImageRef          `json:"image_ref,omitempty" pulumi:"imageRef,optional"`
	IncompleteConfig *FlyMachineConfig  `json:"incomplete_config,omitempty" pulumi:"incompleteConfig,optional"`

	// InstanceId InstanceID is unique for each version of the machine
	InstanceId *string `json:"instance_id,omitempty" pulumi:"instanceId,optional"`
	Name       *string `json:"name,omitempty" pulumi:"name"`

	// Nonce Nonce is only every returned on machine creation if a lease_duration was provided.
	Nonce *string `json:"nonce,omitempty" pulumi:"nonce,optional"`

	// PrivateIp PrivateIP is the internal 6PN address of the machine.
	PrivateIp *string `json:"private_ip,omitempty" pulumi:"privateIp,optional"`
	Region    *string `json:"region,omitempty" pulumi:"region,optional"`
	State     *string `json:"state,omitempty" pulumi:"state"`
	UpdatedAt *string `json:"updated_at,omitempty" pulumi:"updatedAt,optional"`
}

// MachineHostStatus defines model for Machine.HostStatus.
type MachineHostStatus string

// MachineEvent defines model for MachineEvent.
type MachineEvent struct {
	Id        *string                 `json:"id,omitempty" pulumi:"flyId"`
	Request   *map[string]interface{} `json:"request,omitempty" pulumi:"request,optional"`
	Source    *string                 `json:"source,omitempty" pulumi:"source,optional"`
	Status    *string                 `json:"status,omitempty" pulumi:"status,optional"`
	Timestamp *int                    `json:"timestamp,omitempty" pulumi:"timestamp,optional"`
	Type      *string                 `json:"type,omitempty" pulumi:"type,optional"`
}

// MachineExecRequest defines model for MachineExecRequest.
type MachineExecRequest struct {
	// Cmd Deprecated: use Command instead
	Command *[]string `json:"command,omitempty" pulumi:"command,optional"`
	Timeout *int      `json:"timeout,omitempty" pulumi:"timeout,optional"`
}

// MachineVersion defines model for MachineVersion.
type MachineVersion struct {
	UserConfig *FlyMachineConfig `json:"user_config,omitempty" pulumi:"userConfig,optional"`
	Version    *string           `json:"version,omitempty" pulumi:"version,optional"`
}

// Organization defines model for Organization.
type Organization struct {
	Name *string `json:"name,omitempty" pulumi:"name"`
	Slug *string `json:"slug,omitempty" pulumi:"slug"`
}

// ProcessStat defines model for ProcessStat.
type ProcessStat struct {
	Command       *string         `json:"command,omitempty" pulumi:"command,optional"`
	Cpu           *int            `json:"cpu,omitempty" pulumi:"cpu,optional"`
	Directory     *string         `json:"directory,omitempty" pulumi:"directory,optional"`
	ListenSockets *[]ListenSocket `json:"listen_sockets,omitempty" pulumi:"listenSockets,optional"`
	Pid           *int            `json:"pid,omitempty" pulumi:"pid,optional"`
	Rss           *int            `json:"rss,omitempty" pulumi:"rss,optional"`
	Rtime         *int            `json:"rtime,omitempty" pulumi:"rtime,optional"`
	Stime         *int            `json:"stime,omitempty" pulumi:"stime,optional"`
}

// SignalRequest defines model for SignalRequest.
type SignalRequest struct {
	Signal *SignalRequestSignal `json:"signal,omitempty" pulumi:"signal,optional"`
}

// SignalRequestSignal defines model for SignalRequest.Signal.
type SignalRequestSignal string

// StopRequest defines model for StopRequest.
type StopRequest struct {
	Signal  *string      `json:"signal,omitempty" pulumi:"signal,optional"`
	Timeout *string `json:"timeout,omitempty" pulumi:"timeout,optional"`
}

// UpdateMachineRequest defines model for UpdateMachineRequest.
type UpdateMachineRequest struct {
	// Config An object defining the Machine configuration
	Config         *FlyMachineConfig `json:"config,omitempty" pulumi:"config,optional"`
	CurrentVersion *string           `json:"current_version,omitempty" pulumi:"currentVersion,optional"`
	LeaseTtl       *int              `json:"lease_ttl,omitempty" pulumi:"leaseTtl,optional"`
	Lsvd           *bool             `json:"lsvd,omitempty" pulumi:"lsvd,optional"`

	// Name Unique name for this Machine. If omitted, one is generated for you
	Name *string `json:"name,omitempty" pulumi:"name,optional"`

	// Region The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).
	Region                  *string `json:"region,omitempty" pulumi:"region,optional"`
	SkipLaunch              *bool   `json:"skip_launch,omitempty" pulumi:"skipLaunch,optional"`
	SkipServiceRegistration *bool   `json:"skip_service_registration,omitempty" pulumi:"skipServiceRegistration,optional"`
}

// UpdateVolumeRequest defines model for UpdateVolumeRequest.
type UpdateVolumeRequest struct {
	AutoBackupEnabled *bool `json:"auto_backup_enabled,omitempty" pulumi:"autoBackupEnabled,optional"`
	SnapshotRetention *int  `json:"snapshot_retention,omitempty" pulumi:"snapshotRetention,optional"`
}

// Volume defines model for Volume.
type Volume struct {
	AttachedAllocId   *string           `json:"attached_alloc_id,omitempty" pulumi:"attachedAllocId,optional"`
	AttachedMachineId *string           `json:"attached_machine_id,omitempty" pulumi:"attachedMachineId,optional"`
	AutoBackupEnabled *bool             `json:"auto_backup_enabled,omitempty" pulumi:"autoBackupEnabled,optional"`
	BlockSize         *int              `json:"block_size,omitempty" pulumi:"blockSize,optional"`
	Blocks            *int              `json:"blocks,omitempty" pulumi:"blocks,optional"`
	BlocksAvail       *int              `json:"blocks_avail,omitempty" pulumi:"blocksAvail,optional"`
	BlocksFree        *int              `json:"blocks_free,omitempty" pulumi:"blocksFree,optional"`
	CreatedAt         *string           `json:"created_at,omitempty" pulumi:"createdAt,optional"`
	Encrypted         *bool             `json:"encrypted,omitempty" pulumi:"encrypted,optional"`
	Fstype            *string           `json:"fstype,omitempty" pulumi:"fstype,optional"`
	HostStatus        *VolumeHostStatus `json:"host_status,omitempty" pulumi:"hostStatus,optional"`
	Id                *string           `json:"id,omitempty" pulumi:"flyId"`
	Name              *string           `json:"name,omitempty" pulumi:"name,optional"`
	Region            *string           `json:"region,omitempty" pulumi:"region,optional"`
	SizeGb            *int              `json:"size_gb,omitempty" pulumi:"sizeGb,optional"`
	SnapshotRetention *int              `json:"snapshot_retention,omitempty" pulumi:"snapshotRetention,optional"`
	State             *string           `json:"state,omitempty" pulumi:"state,optional"`
	Zone              *string           `json:"zone,omitempty" pulumi:"zone,optional"`
}

// VolumeHostStatus defines model for Volume.HostStatus.
type VolumeHostStatus string

// VolumeSnapshot defines model for VolumeSnapshot.
type VolumeSnapshot struct {
	CreatedAt     *string `json:"created_at,omitempty" pulumi:"createdAt,optional"`
	Digest        *string `json:"digest,omitempty" pulumi:"digest,optional"`
	Id            *string `json:"id,omitempty" pulumi:"flyId"`
	RetentionDays *int    `json:"retention_days,omitempty" pulumi:"retentionDays,optional"`
	Size          *int    `json:"size,omitempty" pulumi:"size,optional"`
	Status        *string `json:"status,omitempty" pulumi:"status,optional"`
}

// FlyDNSConfig defines model for fly.DNSConfig.
type FlyDNSConfig struct {
	DnsForwardRules  *[]FlyDnsForwardRule `json:"dns_forward_rules,omitempty" pulumi:"dnsForwardRules,optional"`
	Hostname         *string              `json:"hostname,omitempty" pulumi:"hostname,optional"`
	HostnameFqdn     *string              `json:"hostname_fqdn,omitempty" pulumi:"hostnameFqdn,optional"`
	Nameservers      *[]string            `json:"nameservers,omitempty" pulumi:"nameservers,optional"`
	Options          *[]FlyDnsOption      `json:"options,omitempty" pulumi:"options,optional"`
	Searches         *[]string            `json:"searches,omitempty" pulumi:"searches,optional"`
	SkipRegistration *bool                `json:"skip_registration,omitempty" pulumi:"skipRegistration,optional"`
}

// string defines model for fly.Duration.
type FlyDuration struct {
	TimeDuration *int `json:"time.Duration,omitempty" pulumi:"timeDuration,optional"`
}

// FlyEnvFrom EnvVar defines an environment variable to be populated from a machine field, env_var
type FlyEnvFrom struct {
	// EnvVar EnvVar is required and is the name of the environment variable that will be set from the
	// secret. It must be a valid environment variable name.
	EnvVar *string `json:"env_var,omitempty" pulumi:"envVar,optional"`

	// FieldRef FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.
	FieldRef *FlyEnvFromFieldRef `json:"field_ref,omitempty" pulumi:"fieldRef,optional"`
}

// FlyEnvFromFieldRef FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.
type FlyEnvFromFieldRef string

// FlyFile A file that will be written to the Machine. One of RawValue or SecretName must be set.
type FlyFile struct {
	// GuestPath GuestPath is the path on the machine where the file will be written and must be an absolute path.
	// For example: /full/path/to/file.json
	GuestPath *string `json:"guest_path,omitempty" pulumi:"guestPath,optional"`

	// Mode Mode bits used to set permissions on this file as accepted by chmod(2).
	Mode *int `json:"mode,omitempty" pulumi:"mode,optional"`

	// RawValue The base64 encoded string of the file contents.
	RawValue *string `json:"raw_value,omitempty" pulumi:"rawValue,optional"`

	// SecretName The name of the secret that contains the base64 encoded file contents.
	SecretName *string `json:"secret_name,omitempty" pulumi:"secretName,optional"`
}

// FlyHTTPOptions defines model for fly.HTTPOptions.
type FlyHTTPOptions struct {
	Compress           *bool                   `json:"compress,omitempty" pulumi:"compress,optional"`
	H2Backend          *bool                   `json:"h2_backend,omitempty" pulumi:"h2Backend,optional"`
	HeadersReadTimeout *int                    `json:"headers_read_timeout,omitempty" pulumi:"headersReadTimeout,optional"`
	IdleTimeout        *int                    `json:"idle_timeout,omitempty" pulumi:"idleTimeout,optional"`
	Response           *FlyHTTPResponseOptions `json:"response,omitempty" pulumi:"response,optional"`
}

// FlyHTTPResponseOptions defines model for fly.HTTPResponseOptions.
type FlyHTTPResponseOptions struct {
	Headers  *map[string]map[string]interface{} `json:"headers,omitempty" pulumi:"headers,optional"`
	Pristine *bool                              `json:"pristine,omitempty" pulumi:"pristine,optional"`
}

// FlyMachineCheck An optional object that defines one or more named checks. The key for each check is the check name.
type FlyMachineCheck struct {
	// GracePeriod The time to wait after a VM starts before checking its health
	GracePeriod *string            `json:"grace_period,omitempty" pulumi:"gracePeriod,optional"`
	Headers     *[]FlyMachineHTTPHeader `json:"headers,omitempty" pulumi:"headers,optional"`

	// Interval The time between connectivity checks
	Interval *string `json:"interval,omitempty" pulumi:"interval,optional"`

	// Kind Kind of the check (informational, readiness)
	Kind *FlyMachineCheckKind `json:"kind,omitempty" pulumi:"kind,optional"`

	// Method For http checks, the HTTP method to use to when making the request
	Method *string `json:"method,omitempty" pulumi:"method,optional"`

	// Path For http checks, the path to send the request to
	Path *string `json:"path,omitempty" pulumi:"path,optional"`

	// Port The port to connect to, often the same as internal_port
	Port *int `json:"port,omitempty" pulumi:"port,optional"`

	// Protocol For http checks, whether to use http or https
	Protocol *string `json:"protocol,omitempty" pulumi:"protocol,optional"`

	// Timeout The maximum time a connection can take before being reported as failing its health check
	Timeout *string `json:"timeout,omitempty" pulumi:"timeout,optional"`

	// TlsServerName If the protocol is https, the hostname to use for TLS certificate validation
	TlsServerName *string `json:"tls_server_name,omitempty" pulumi:"tlsServerName,optional"`

	// TlsSkipVerify For http checks with https protocol, whether or not to verify the TLS certificate
	TlsSkipVerify *bool `json:"tls_skip_verify,omitempty" pulumi:"tlsSkipVerify,optional"`

	// Type tcp or http
	Type *string `json:"type,omitempty" pulumi:"type,optional"`
}

// FlyMachineCheckKind Kind of the check (informational, readiness)
type FlyMachineCheckKind string

// FlyMachineConfig defines model for fly.MachineConfig.
type FlyMachineConfig struct {
	// AutoDestroy Optional boolean telling the Machine to destroy itself once it’s complete (default false)
	AutoDestroy *bool                       `json:"auto_destroy,omitempty" pulumi:"autoDestroy,optional"`
	Checks      *map[string]FlyMachineCheck `json:"checks,omitempty" pulumi:"checks,optional"`

	// DisableMachineAutostart Deprecated: use Service.Autostart instead
	Dns                     *FlyDNSConfig `json:"dns,omitempty" pulumi:"dns,optional"`

	// Env An object filled with key/value pairs to be set as environment variables
	Env   *map[string]string `json:"env,omitempty" pulumi:"env,optional"`
	Files *[]FlyFile         `json:"files,omitempty" pulumi:"files,optional"`
	Guest *FlyMachineGuest   `json:"guest,omitempty" pulumi:"guest,optional"`

	// Image The docker image to run
	Image     *string              `json:"image,omitempty" pulumi:"image"`
	Init      *FlyMachineInit      `json:"init,omitempty" pulumi:"init,optional"`
	Metadata  *map[string]string   `json:"metadata,omitempty" pulumi:"metadata,optional"`
	Metrics   *FlyMachineMetrics   `json:"metrics,omitempty" pulumi:"metrics,optional"`
	Mounts    *[]FlyMachineMount   `json:"mounts,omitempty" pulumi:"mounts,optional"`
	Processes *[]FlyMachineProcess `json:"processes,omitempty" pulumi:"processes,optional"`

	// Restart The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.
	Restart  *FlyMachineRestart   `json:"restart,omitempty" pulumi:"restart,optional"`
	Schedule *string              `json:"schedule,omitempty" pulumi:"schedule,optional"`
	Services *[]FlyMachineService `json:"services,omitempty" pulumi:"services,optional"`

	// Size Deprecated: use Guest instead

	// Standbys Standbys enable a machine to be a standby for another. In the event of a hardware failure,
	// the standby machine will be started.
	Standbys   *[]string      `json:"standbys,omitempty" pulumi:"standbys,optional"`
	Statics    *[]FlyStatic   `json:"statics,omitempty" pulumi:"statics,optional"`
	StopConfig *FlyStopConfig `json:"stop_config,omitempty" pulumi:"stopConfig,optional"`
}

// FlyMachineGuest defines model for fly.MachineGuest.
type FlyMachineGuest struct {
	CpuKind          *string   `json:"cpu_kind,omitempty" pulumi:"cpuKind"`
	Cpus             *int      `json:"cpus,omitempty" pulumi:"cpus"`
	GpuKind          *string   `json:"gpu_kind,omitempty" pulumi:"gpuKind,optional"`
	Gpus             *int      `json:"gpus,omitempty" pulumi:"gpus,optional"`
	HostDedicationId *string   `json:"host_dedication_id,omitempty" pulumi:"hostDedicationId,optional"`
	KernelArgs       *[]string `json:"kernel_args,omitempty" pulumi:"kernelArgs,optional"`
	MemoryMb         *int      `json:"memory_mb,omitempty" pulumi:"memoryMb"`
}

// FlyMachineHTTPHeader For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.
type FlyMachineHTTPHeader struct {
	// Name The header name
	Name *string `json:"name,omitempty" pulumi:"name,optional"`

	// Values The header value
	Values *[]string `json:"values,omitempty" pulumi:"values,optional"`
}

// FlyMachineInit defines model for fly.MachineInit.
type FlyMachineInit struct {
	Cmd        *[]string `json:"cmd,omitempty" pulumi:"cmd,optional"`
	Entrypoint *[]string `json:"entrypoint,omitempty" pulumi:"entrypoint,optional"`
	Exec       *[]string `json:"exec,omitempty" pulumi:"exec,optional"`
	KernelArgs *[]string `json:"kernel_args,omitempty" pulumi:"kernelArgs,optional"`
	SwapSizeMb *int      `json:"swap_size_mb,omitempty" pulumi:"swapSizeMb,optional"`
	Tty        *bool     `json:"tty,omitempty" pulumi:"tty,optional"`
}

// FlyMachineMetrics defines model for fly.MachineMetrics.
type FlyMachineMetrics struct {
	Path *string `json:"path,omitempty" pulumi:"path,optional"`
	Port *int    `json:"port,omitempty" pulumi:"port,optional"`
}

// FlyMachineMount defines model for fly.MachineMount.
type FlyMachineMount struct {
	AddSizeGb              *int    `json:"add_size_gb,omitempty" pulumi:"addSizeGb,optional"`
	Encrypted              *bool   `json:"encrypted,omitempty" pulumi:"encrypted,optional"`
	ExtendThresholdPercent *int    `json:"extend_threshold_percent,omitempty" pulumi:"extendThresholdPercent,optional"`
	Name                   *string `json:"name,omitempty" pulumi:"name,optional"`
	Path                   *string `json:"path,omitempty" pulumi:"path,optional"`
	SizeGb                 *int    `json:"size_gb,omitempty" pulumi:"sizeGb,optional"`
	SizeGbLimit            *int    `json:"size_gb_limit,omitempty" pulumi:"sizeGbLimit,optional"`
	Volume                 *string `json:"volume,omitempty" pulumi:"volume,optional"`
}

// FlyMachinePort defines model for fly.MachinePort.
type FlyMachinePort struct {
	EndPort           *int                  `json:"end_port,omitempty" pulumi:"endPort,optional"`
	ForceHttps        *bool                 `json:"force_https,omitempty" pulumi:"forceHttps,optional"`
	Handlers          *[]string             `json:"handlers,omitempty" pulumi:"handlers,optional"`
	HttpOptions       *FlyHTTPOptions       `json:"http_options,omitempty" pulumi:"httpOptions,optional"`
	Port              *int                  `json:"port,omitempty" pulumi:"port,optional"`
	ProxyProtoOptions *FlyProxyProtoOptions `json:"proxy_proto_options,omitempty" pulumi:"proxyProtoOptions,optional"`
	StartPort         *int                  `json:"start_port,omitempty" pulumi:"startPort,optional"`
	TlsOptions        *FlyTLSOptions        `json:"tls_options,omitempty" pulumi:"tlsOptions,optional"`
}

// FlyMachineProcess defines model for fly.MachineProcess.
type FlyMachineProcess struct {
	Cmd        *[]string          `json:"cmd,omitempty" pulumi:"cmd,optional"`
	Entrypoint *[]string          `json:"entrypoint,omitempty" pulumi:"entrypoint,optional"`
	Env        *map[string]string `json:"env,omitempty" pulumi:"env,optional"`

	// EnvFrom EnvFrom can be provided to set environment variables from machine fields.
	EnvFrom *[]FlyEnvFrom `json:"env_from,omitempty" pulumi:"envFrom,optional"`
	Exec    *[]string     `json:"exec,omitempty" pulumi:"exec,optional"`

	// IgnoreAppSecrets IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to
	// and only use the secrets provided at the process level. The default/legacy behavior is to use
	// the secrets provided at the App level.
	IgnoreAppSecrets *bool `json:"ignore_app_secrets,omitempty" pulumi:"ignoreAppSecrets,optional"`

	// Secrets Secrets can be provided at the process level to explicitly indicate which secrets should be
	// used for the process. If not provided, the secrets provided at the machine level will be used.
	Secrets *[]FlyMachineSecret `json:"secrets,omitempty" pulumi:"secrets,optional"`
	User    *string             `json:"user,omitempty" pulumi:"user,optional"`
}

// FlyMachineRestart The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.
type FlyMachineRestart struct {
	// GpuBidPrice GPU bid price for spot Machines.
	GpuBidPrice *float64 `json:"gpu_bid_price,omitempty" pulumi:"gpuBidPrice,optional"`

	// MaxRetries When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop.
	MaxRetries *int `json:"max_retries,omitempty" pulumi:"maxRetries,optional"`

	// Policy * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
	// * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
	// * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
	// * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
	Policy *FlyMachineRestartPolicy `json:"policy,omitempty" pulumi:"policy,optional"`
}

// FlyMachineRestartPolicy * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
// * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
// * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
// * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
type FlyMachineRestartPolicy string

// FlyMachineSecret A Secret needing to be set in the environment of the Machine. env_var is required
type FlyMachineSecret struct {
	// EnvVar EnvVar is required and is the name of the environment variable that will be set from the
	// secret. It must be a valid environment variable name.
	EnvVar *string `json:"env_var,omitempty" pulumi:"envVar,optional"`

	// Name Name is optional and when provided is used to reference a secret name where the EnvVar is
	// different from what was set as the secret name.
	Name *string `json:"name,omitempty" pulumi:"name,optional"`
}

// FlyMachineService defines model for fly.MachineService.
type FlyMachineService struct {
	Autostart *bool `json:"autostart,omitempty" pulumi:"autostart,optional"`

	// Autostop Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
	// * "off" or false - Do not autostop the Machine.
	// * "stop" or true - Automatically stop the Machine.
	// * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
	Autostop                 *FlyMachineServiceAutostop    `json:"autostop,omitempty" pulumi:"autostop,optional"`
	Checks                   *[]FlyMachineCheck            `json:"checks,omitempty" pulumi:"checks,optional"`
	Concurrency              *FlyMachineServiceConcurrency `json:"concurrency,omitempty" pulumi:"concurrency,optional"`
	ForceInstanceDescription *string                       `json:"force_instance_description,omitempty" pulumi:"forceInstanceDescription,optional"`
	ForceInstanceKey         *string                       `json:"force_instance_key,omitempty" pulumi:"forceInstanceKey,optional"`
	InternalPort             *int                          `json:"internal_port,omitempty" pulumi:"internalPort,optional"`
	MinMachinesRunning       *int                          `json:"min_machines_running,omitempty" pulumi:"minMachinesRunning,optional"`
	Ports                    *[]FlyMachinePort             `json:"ports,omitempty" pulumi:"ports,optional"`
	Protocol                 *string                       `json:"protocol,omitempty" pulumi:"protocol,optional"`
}

// FlyMachineServiceAutostop Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
// * "off" or false - Do not autostop the Machine.
// * "stop" or true - Automatically stop the Machine.
// * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
type FlyMachineServiceAutostop string

// FlyMachineServiceConcurrency defines model for fly.MachineServiceConcurrency.
type FlyMachineServiceConcurrency struct {
	HardLimit *int    `json:"hard_limit,omitempty" pulumi:"hardLimit,optional"`
	SoftLimit *int    `json:"soft_limit,omitempty" pulumi:"softLimit,optional"`
	Type      *string `json:"type,omitempty" pulumi:"type,optional"`
}

// FlyProxyProtoOptions defines model for fly.ProxyProtoOptions.
type FlyProxyProtoOptions struct {
	Version *string `json:"version,omitempty" pulumi:"version,optional"`
}

// FlyStatic defines model for fly.Static.
type FlyStatic struct {
	GuestPath     string  `json:"guest_path" pulumi:"guestPath"`
	IndexDocument *string `json:"index_document,omitempty" pulumi:"indexDocument,optional"`
	TigrisBucket  *string `json:"tigris_bucket,omitempty" pulumi:"tigrisBucket,optional"`
	UrlPrefix     string  `json:"url_prefix" pulumi:"urlPrefix"`
}

// FlyStopConfig defines model for fly.StopConfig.
type FlyStopConfig struct {
	Signal  *string      `json:"signal,omitempty" pulumi:"signal,optional"`
	Timeout *string `json:"timeout,omitempty" pulumi:"timeout,optional"`
}

// FlyTLSOptions defines model for fly.TLSOptions.
type FlyTLSOptions struct {
	Alpn              *[]string `json:"alpn,omitempty" pulumi:"alpn,optional"`
	DefaultSelfSigned *bool     `json:"default_self_signed,omitempty" pulumi:"defaultSelfSigned,optional"`
	Versions          *[]string `json:"versions,omitempty" pulumi:"versions,optional"`
}

// FlyDnsForwardRule defines model for fly.dnsForwardRule.
type FlyDnsForwardRule struct {
	Addr     *string `json:"addr,omitempty" pulumi:"addr,optional"`
	Basename *string `json:"basename,omitempty" pulumi:"basename,optional"`
}

// FlyDnsOption defines model for fly.dnsOption.
type FlyDnsOption struct {
	Name  *string `json:"name,omitempty" pulumi:"name,optional"`
	Value *string `json:"value,omitempty" pulumi:"value,optional"`
}

// Flydv1ExecResponse defines model for flydv1.ExecResponse.
type Flydv1ExecResponse struct {
	ExitCode   *int    `json:"exit_code,omitempty" pulumi:"exitCode,optional"`
	ExitSignal *int    `json:"exit_signal,omitempty" pulumi:"exitSignal,optional"`
	Stderr     *string `json:"stderr,omitempty" pulumi:"stderr,optional"`
	Stdout     *string `json:"stdout,omitempty" pulumi:"stdout,optional"`
}

// MainStatusCode defines model for main.statusCode.
type MainStatusCode string

// AppsListParams defines parameters for AppsList.
type AppsListParams struct {
	// OrgSlug The org slug, or 'personal', to filter apps
	OrgSlug string `form:"org_slug" json:"org_slug"`
}

// MachinesListParams defines parameters for MachinesList.
type MachinesListParams struct {
	// IncludeDeleted Include deleted machines
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// Region Region filter
	Region *string `form:"region,omitempty" json:"region,omitempty"`

	// Summary Only return summary info about machines (omit config, checks, events, host_status, nonce, etc.)
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// MachinesDeleteParams defines parameters for MachinesDelete.
type MachinesDeleteParams struct {
	// Force Force kill the machine if it's running
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// MachinesReleaseLeaseParams defines parameters for MachinesReleaseLease.
type MachinesReleaseLeaseParams struct {
	// FlyMachineLeaseNonce Existing lease nonce
	FlyMachineLeaseNonce string `json:"fly-machine-lease-nonce" pulumi:"flyMachineLeaseNonce"`
}

// MachinesCreateLeaseParams defines parameters for MachinesCreateLease.
type MachinesCreateLeaseParams struct {
	// FlyMachineLeaseNonce Existing lease nonce to refresh by ttl, empty or non-existent to create a new lease
	FlyMachineLeaseNonce *string `json:"fly-machine-lease-nonce,omitempty" pulumi:"flyMachineLeaseNonce,optional"`
}

// MachinesListProcessesParams defines parameters for MachinesListProcesses.
type MachinesListProcessesParams struct {
	// SortBy Sort by
	SortBy *string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Order Order
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// MachinesRestartParams defines parameters for MachinesRestart.
type MachinesRestartParams struct {
	// Timeout Restart timeout as a Go duration string or number of seconds
	Timeout *string `form:"timeout,omitempty" json:"timeout,omitempty"`

	// Signal Unix signal name
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`
}

// MachinesWaitParams defines parameters for MachinesWait.
type MachinesWaitParams struct {
	// InstanceId 26-character Machine version ID
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// Timeout wait timeout. default 60s
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`

	// State desired state
	State *MachinesWaitParamsState `form:"state,omitempty" json:"state,omitempty"`
}

// MachinesWaitParamsState defines parameters for MachinesWait.
type MachinesWaitParamsState string

// VolumesListParams defines parameters for VolumesList.
type VolumesListParams struct {
	// Summary Only return summary info about volumes (omit blocks, block size, etc)
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// AppsCreateJSONRequestBody defines body for AppsCreate for application/json ContentType.
type AppsCreateJSONRequestBody = CreateAppRequest

// MachinesCreateJSONRequestBody defines body for MachinesCreate for application/json ContentType.
type MachinesCreateJSONRequestBody = CreateMachineRequest

// MachinesUpdateJSONRequestBody defines body for MachinesUpdate for application/json ContentType.
type MachinesUpdateJSONRequestBody = UpdateMachineRequest

// MachinesExecJSONRequestBody defines body for MachinesExec for application/json ContentType.
type MachinesExecJSONRequestBody = MachineExecRequest

// MachinesCreateLeaseJSONRequestBody defines body for MachinesCreateLease for application/json ContentType.
type MachinesCreateLeaseJSONRequestBody = CreateLeaseRequest

// MachinesSignalJSONRequestBody defines body for MachinesSignal for application/json ContentType.
type MachinesSignalJSONRequestBody = SignalRequest

// MachinesStopJSONRequestBody defines body for MachinesStop for application/json ContentType.
type MachinesStopJSONRequestBody = StopRequest

// VolumesCreateJSONRequestBody defines body for VolumesCreate for application/json ContentType.
type VolumesCreateJSONRequestBody = CreateVolumeRequest

// VolumesUpdateJSONRequestBody defines body for VolumesUpdate for application/json ContentType.
type VolumesUpdateJSONRequestBody = UpdateVolumeRequest

// VolumesExtendJSONRequestBody defines body for VolumesExtend for application/json ContentType.
type VolumesExtendJSONRequestBody = ExtendVolumeRequest

// TokensRequestOIDCJSONRequestBody defines body for TokensRequestOIDC for application/json ContentType.
type TokensRequestOIDCJSONRequestBody = CreateOIDCTokenRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AppsList request
	AppsList(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsCreateWithBody request with any body
	AppsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsCreate(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsDelete request
	AppsDelete(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsShow request
	AppsShow(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesList request
	MachinesList(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCreateWithBody request with any body
	MachinesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesCreate(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesDelete request
	MachinesDelete(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShow request
	MachinesShow(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUpdateWithBody request with any body
	MachinesUpdateWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesUpdate(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCordon request
	MachinesCordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListEvents request
	MachinesListEvents(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesExecWithBody request with any body
	MachinesExecWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesExec(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesReleaseLease request
	MachinesReleaseLease(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShowLease request
	MachinesShowLease(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCreateLeaseWithBody request with any body
	MachinesCreateLeaseWithBody(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesCreateLease(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShowMetadata request
	MachinesShowMetadata(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesDeleteMetadata request
	MachinesDeleteMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUpdateMetadata request
	MachinesUpdateMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListProcesses request
	MachinesListProcesses(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesRestart request
	MachinesRestart(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesSignalWithBody request with any body
	MachinesSignalWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesSignal(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStart request
	MachinesStart(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStopWithBody request with any body
	MachinesStopWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesStop(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesSuspend request
	MachinesSuspend(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUncordon request
	MachinesUncordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListVersions request
	MachinesListVersions(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesWait request
	MachinesWait(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretsList request
	SecretsList(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesList request
	VolumesList(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesCreateWithBody request with any body
	VolumesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesCreate(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumeDelete request
	VolumeDelete(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesGetById request
	VolumesGetById(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesUpdateWithBody request with any body
	VolumesUpdateWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesUpdate(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesExtendWithBody request with any body
	VolumesExtendWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesExtend(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesListSnapshots request
	VolumesListSnapshots(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeSnapshot request
	CreateVolumeSnapshot(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokensRequestKms request
	TokensRequestKms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokensRequestOIDCWithBody request with any body
	TokensRequestOIDCWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokensRequestOIDC(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AppsList(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsCreate(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsDelete(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsDeleteRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsShow(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsShowRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesList(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListRequest(c.Server, appName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreate(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesDelete(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesDeleteRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShow(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdateWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdate(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCordonRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListEvents(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListEventsRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesExecWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesExecRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesExec(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesExecRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesReleaseLease(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesReleaseLeaseRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShowLease(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowLeaseRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateLeaseWithBody(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateLeaseRequestWithBody(c.Server, appName, machineId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateLease(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateLeaseRequest(c.Server, appName, machineId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShowMetadata(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowMetadataRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesDeleteMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesDeleteMetadataRequest(c.Server, appName, machineId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdateMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateMetadataRequest(c.Server, appName, machineId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListProcesses(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListProcessesRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesRestart(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesRestartRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSignalWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSignalRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSignal(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSignalRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStart(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStartRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStopWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStopRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStop(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStopRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSuspend(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSuspendRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUncordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUncordonRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListVersions(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListVersionsRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesWait(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesWaitRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretsList(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretsListRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesList(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesListRequest(c.Server, appName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesCreateRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesCreate(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesCreateRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumeDelete(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumeDeleteRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesGetById(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesGetByIdRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesUpdateWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesUpdateRequestWithBody(c.Server, appName, volumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesUpdate(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesUpdateRequest(c.Server, appName, volumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesExtendWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesExtendRequestWithBody(c.Server, appName, volumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesExtend(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesExtendRequest(c.Server, appName, volumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesListSnapshots(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesListSnapshotsRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeSnapshot(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeSnapshotRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestKms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestKmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestOIDCWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestOIDCRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestOIDC(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestOIDCRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAppsListRequest generates requests for AppsList
func NewAppsListRequest(server string, params *AppsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_slug", runtime.ParamLocationQuery, params.OrgSlug); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsCreateRequest calls the generic AppsCreate builder with application/json body
func NewAppsCreateRequest(server string, body AppsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAppsCreateRequestWithBody generates requests for AppsCreate with any type of body
func NewAppsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsDeleteRequest generates requests for AppsDelete
func NewAppsDeleteRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsShowRequest generates requests for AppsShow
func NewAppsShowRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListRequest generates requests for MachinesList
func NewMachinesListRequest(server string, appName string, params *MachinesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesCreateRequest calls the generic MachinesCreate builder with application/json body
func NewMachinesCreateRequest(server string, appName string, body MachinesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesCreateRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewMachinesCreateRequestWithBody generates requests for MachinesCreate with any type of body
func NewMachinesCreateRequestWithBody(server string, appName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesDeleteRequest generates requests for MachinesDelete
func NewMachinesDeleteRequest(server string, appName string, machineId string, params *MachinesDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesShowRequest generates requests for MachinesShow
func NewMachinesShowRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUpdateRequest calls the generic MachinesUpdate builder with application/json body
func NewMachinesUpdateRequest(server string, appName string, machineId string, body MachinesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesUpdateRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesUpdateRequestWithBody generates requests for MachinesUpdate with any type of body
func NewMachinesUpdateRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesCordonRequest generates requests for MachinesCordon
func NewMachinesCordonRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/cordon", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListEventsRequest generates requests for MachinesListEvents
func NewMachinesListEventsRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesExecRequest calls the generic MachinesExec builder with application/json body
func NewMachinesExecRequest(server string, appName string, machineId string, body MachinesExecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesExecRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesExecRequestWithBody generates requests for MachinesExec with any type of body
func NewMachinesExecRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/exec", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesReleaseLeaseRequest generates requests for MachinesReleaseLease
func NewMachinesReleaseLeaseRequest(server string, appName string, machineId string, params *MachinesReleaseLeaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "fly-machine-lease-nonce", runtime.ParamLocationHeader, params.FlyMachineLeaseNonce)
		if err != nil {
			return nil, err
		}

		req.Header.Set("fly-machine-lease-nonce", headerParam0)

	}

	return req, nil
}

// NewMachinesShowLeaseRequest generates requests for MachinesShowLease
func NewMachinesShowLeaseRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesCreateLeaseRequest calls the generic MachinesCreateLease builder with application/json body
func NewMachinesCreateLeaseRequest(server string, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesCreateLeaseRequestWithBody(server, appName, machineId, params, "application/json", bodyReader)
}

// NewMachinesCreateLeaseRequestWithBody generates requests for MachinesCreateLease with any type of body
func NewMachinesCreateLeaseRequestWithBody(server string, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FlyMachineLeaseNonce != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "fly-machine-lease-nonce", runtime.ParamLocationHeader, *params.FlyMachineLeaseNonce)
			if err != nil {
				return nil, err
			}

			req.Header.Set("fly-machine-lease-nonce", headerParam0)
		}

	}

	return req, nil
}

// NewMachinesShowMetadataRequest generates requests for MachinesShowMetadata
func NewMachinesShowMetadataRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesDeleteMetadataRequest generates requests for MachinesDeleteMetadata
func NewMachinesDeleteMetadataRequest(server string, appName string, machineId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUpdateMetadataRequest generates requests for MachinesUpdateMetadata
func NewMachinesUpdateMetadataRequest(server string, appName string, machineId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListProcessesRequest generates requests for MachinesListProcesses
func NewMachinesListProcessesRequest(server string, appName string, machineId string, params *MachinesListProcessesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/ps", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesRestartRequest generates requests for MachinesRestart
func NewMachinesRestartRequest(server string, appName string, machineId string, params *MachinesRestartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/restart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesSignalRequest calls the generic MachinesSignal builder with application/json body
func NewMachinesSignalRequest(server string, appName string, machineId string, body MachinesSignalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesSignalRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesSignalRequestWithBody generates requests for MachinesSignal with any type of body
func NewMachinesSignalRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/signal", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesStartRequest generates requests for MachinesStart
func NewMachinesStartRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesStopRequest calls the generic MachinesStop builder with application/json body
func NewMachinesStopRequest(server string, appName string, machineId string, body MachinesStopJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesStopRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesStopRequestWithBody generates requests for MachinesStop with any type of body
func NewMachinesStopRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesSuspendRequest generates requests for MachinesSuspend
func NewMachinesSuspendRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/suspend", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUncordonRequest generates requests for MachinesUncordon
func NewMachinesUncordonRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/uncordon", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListVersionsRequest generates requests for MachinesListVersions
func NewMachinesListVersionsRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesWaitRequest generates requests for MachinesWait
func NewMachinesWaitRequest(server string, appName string, machineId string, params *MachinesWaitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/wait", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretsListRequest generates requests for SecretsList
func NewSecretsListRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesListRequest generates requests for VolumesList
func NewVolumesListRequest(server string, appName string, params *VolumesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesCreateRequest calls the generic VolumesCreate builder with application/json body
func NewVolumesCreateRequest(server string, appName string, body VolumesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesCreateRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewVolumesCreateRequestWithBody generates requests for VolumesCreate with any type of body
func NewVolumesCreateRequestWithBody(server string, appName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumeDeleteRequest generates requests for VolumeDelete
func NewVolumeDeleteRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesGetByIdRequest generates requests for VolumesGetById
func NewVolumesGetByIdRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesUpdateRequest calls the generic VolumesUpdate builder with application/json body
func NewVolumesUpdateRequest(server string, appName string, volumeId string, body VolumesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesUpdateRequestWithBody(server, appName, volumeId, "application/json", bodyReader)
}

// NewVolumesUpdateRequestWithBody generates requests for VolumesUpdate with any type of body
func NewVolumesUpdateRequestWithBody(server string, appName string, volumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumesExtendRequest calls the generic VolumesExtend builder with application/json body
func NewVolumesExtendRequest(server string, appName string, volumeId string, body VolumesExtendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesExtendRequestWithBody(server, appName, volumeId, "application/json", bodyReader)
}

// NewVolumesExtendRequestWithBody generates requests for VolumesExtend with any type of body
func NewVolumesExtendRequestWithBody(server string, appName string, volumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/extend", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumesListSnapshotsRequest generates requests for VolumesListSnapshots
func NewVolumesListSnapshotsRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/snapshots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeSnapshotRequest generates requests for CreateVolumeSnapshot
func NewCreateVolumeSnapshotRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/snapshots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokensRequestKmsRequest generates requests for TokensRequestKms
func NewTokensRequestKmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/kms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokensRequestOIDCRequest calls the generic TokensRequestOIDC builder with application/json body
func NewTokensRequestOIDCRequest(server string, body TokensRequestOIDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokensRequestOIDCRequestWithBody(server, "application/json", bodyReader)
}

// NewTokensRequestOIDCRequestWithBody generates requests for TokensRequestOIDC with any type of body
func NewTokensRequestOIDCRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/oidc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AppsListWithResponse request
	AppsListWithResponse(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*AppsListResponse, error)

	// AppsCreateWithBodyWithResponse request with any body
	AppsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error)

	AppsCreateWithResponse(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error)

	// AppsDeleteWithResponse request
	AppsDeleteWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsDeleteResponse, error)

	// AppsShowWithResponse request
	AppsShowWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsShowResponse, error)

	// MachinesListWithResponse request
	MachinesListWithResponse(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error)

	// MachinesCreateWithBodyWithResponse request with any body
	MachinesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	MachinesCreateWithResponse(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	// MachinesDeleteWithResponse request
	MachinesDeleteWithResponse(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error)

	// MachinesShowWithResponse request
	MachinesShowWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowResponse, error)

	// MachinesUpdateWithBodyWithResponse request with any body
	MachinesUpdateWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	MachinesUpdateWithResponse(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	// MachinesCordonWithResponse request
	MachinesCordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesCordonResponse, error)

	// MachinesListEventsWithResponse request
	MachinesListEventsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListEventsResponse, error)

	// MachinesExecWithBodyWithResponse request with any body
	MachinesExecWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error)

	MachinesExecWithResponse(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error)

	// MachinesReleaseLeaseWithResponse request
	MachinesReleaseLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*MachinesReleaseLeaseResponse, error)

	// MachinesShowLeaseWithResponse request
	MachinesShowLeaseWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowLeaseResponse, error)

	// MachinesCreateLeaseWithBodyWithResponse request with any body
	MachinesCreateLeaseWithBodyWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error)

	MachinesCreateLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error)

	// MachinesShowMetadataWithResponse request
	MachinesShowMetadataWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowMetadataResponse, error)

	// MachinesDeleteMetadataWithResponse request
	MachinesDeleteMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesDeleteMetadataResponse, error)

	// MachinesUpdateMetadataWithResponse request
	MachinesUpdateMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesUpdateMetadataResponse, error)

	// MachinesListProcessesWithResponse request
	MachinesListProcessesWithResponse(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*MachinesListProcessesResponse, error)

	// MachinesRestartWithResponse request
	MachinesRestartWithResponse(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error)

	// MachinesSignalWithBodyWithResponse request with any body
	MachinesSignalWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error)

	MachinesSignalWithResponse(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error)

	// MachinesStartWithResponse request
	MachinesStartWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error)

	// MachinesStopWithBodyWithResponse request with any body
	MachinesStopWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error)

	MachinesStopWithResponse(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error)

	// MachinesSuspendWithResponse request
	MachinesSuspendWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesSuspendResponse, error)

	// MachinesUncordonWithResponse request
	MachinesUncordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesUncordonResponse, error)

	// MachinesListVersionsWithResponse request
	MachinesListVersionsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListVersionsResponse, error)

	// MachinesWaitWithResponse request
	MachinesWaitWithResponse(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*MachinesWaitResponse, error)

	// SecretsListWithResponse request
	SecretsListWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*SecretsListResponse, error)

	// VolumesListWithResponse request
	VolumesListWithResponse(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*VolumesListResponse, error)

	// VolumesCreateWithBodyWithResponse request with any body
	VolumesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error)

	VolumesCreateWithResponse(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error)

	// VolumeDeleteWithResponse request
	VolumeDeleteWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumeDeleteResponse, error)

	// VolumesGetByIdWithResponse request
	VolumesGetByIdWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesGetByIdResponse, error)

	// VolumesUpdateWithBodyWithResponse request with any body
	VolumesUpdateWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error)

	VolumesUpdateWithResponse(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error)

	// VolumesExtendWithBodyWithResponse request with any body
	VolumesExtendWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error)

	VolumesExtendWithResponse(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error)

	// VolumesListSnapshotsWithResponse request
	VolumesListSnapshotsWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesListSnapshotsResponse, error)

	// CreateVolumeSnapshotWithResponse request
	CreateVolumeSnapshotWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotResponse, error)

	// TokensRequestKmsWithResponse request
	TokensRequestKmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokensRequestKmsResponse, error)

	// TokensRequestOIDCWithBodyWithResponse request with any body
	TokensRequestOIDCWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error)

	TokensRequestOIDCWithResponse(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error)
}

type AppsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAppsResponse
}

// Status returns HTTPResponse.Status
func (r AppsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
}

// Status returns HTTPResponse.Status
func (r AppsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Machine
}

// Status returns HTTPResponse.Status
func (r MachinesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
}

// Status returns HTTPResponse.Status
func (r MachinesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
}

// Status returns HTTPResponse.Status
func (r MachinesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCordonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesCordonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCordonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MachineEvent
}

// Status returns HTTPResponse.Status
func (r MachinesListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesExecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flydv1ExecResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesExecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesExecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesReleaseLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesReleaseLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesReleaseLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lease
}

// Status returns HTTPResponse.Status
func (r MachinesShowLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCreateLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lease
}

// Status returns HTTPResponse.Status
func (r MachinesCreateLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCreateLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r MachinesShowMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesDeleteMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesDeleteMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesDeleteMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUpdateMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesUpdateMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUpdateMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProcessStat
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesListProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesSignalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesSignalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesSignalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesSuspendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesSuspendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesSuspendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUncordonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesUncordonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUncordonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MachineVersion
}

// Status returns HTTPResponse.Status
func (r MachinesListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesWaitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesWaitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesWaitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListSecret
}

// Status returns HTTPResponse.Status
func (r SecretsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Volume
}

// Status returns HTTPResponse.Status
func (r VolumesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumeDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumeDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumeDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumesGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VolumesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesExtendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtendVolumeResponse
}

// Status returns HTTPResponse.Status
func (r VolumesExtendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesExtendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesListSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VolumeSnapshot
}

// Status returns HTTPResponse.Status
func (r VolumesListSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesListSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVolumeSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokensRequestKmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r TokensRequestKmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokensRequestKmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokensRequestOIDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TokensRequestOIDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokensRequestOIDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AppsListWithResponse request returning *AppsListResponse
func (c *ClientWithResponses) AppsListWithResponse(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*AppsListResponse, error) {
	rsp, err := c.AppsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsListResponse(rsp)
}

// AppsCreateWithBodyWithResponse request with arbitrary body returning *AppsCreateResponse
func (c *ClientWithResponses) AppsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error) {
	rsp, err := c.AppsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsCreateResponse(rsp)
}

func (c *ClientWithResponses) AppsCreateWithResponse(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error) {
	rsp, err := c.AppsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsCreateResponse(rsp)
}

// AppsDeleteWithResponse request returning *AppsDeleteResponse
func (c *ClientWithResponses) AppsDeleteWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsDeleteResponse, error) {
	rsp, err := c.AppsDelete(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsDeleteResponse(rsp)
}

// AppsShowWithResponse request returning *AppsShowResponse
func (c *ClientWithResponses) AppsShowWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsShowResponse, error) {
	rsp, err := c.AppsShow(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsShowResponse(rsp)
}

// MachinesListWithResponse request returning *MachinesListResponse
func (c *ClientWithResponses) MachinesListWithResponse(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error) {
	rsp, err := c.MachinesList(ctx, appName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListResponse(rsp)
}

// MachinesCreateWithBodyWithResponse request with arbitrary body returning *MachinesCreateResponse
func (c *ClientWithResponses) MachinesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreateWithBody(ctx, appName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

func (c *ClientWithResponses) MachinesCreateWithResponse(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreate(ctx, appName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

// MachinesDeleteWithResponse request returning *MachinesDeleteResponse
func (c *ClientWithResponses) MachinesDeleteWithResponse(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error) {
	rsp, err := c.MachinesDelete(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesDeleteResponse(rsp)
}

// MachinesShowWithResponse request returning *MachinesShowResponse
func (c *ClientWithResponses) MachinesShowWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowResponse, error) {
	rsp, err := c.MachinesShow(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowResponse(rsp)
}

// MachinesUpdateWithBodyWithResponse request with arbitrary body returning *MachinesUpdateResponse
func (c *ClientWithResponses) MachinesUpdateWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdateWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

func (c *ClientWithResponses) MachinesUpdateWithResponse(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdate(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

// MachinesCordonWithResponse request returning *MachinesCordonResponse
func (c *ClientWithResponses) MachinesCordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesCordonResponse, error) {
	rsp, err := c.MachinesCordon(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCordonResponse(rsp)
}

// MachinesListEventsWithResponse request returning *MachinesListEventsResponse
func (c *ClientWithResponses) MachinesListEventsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListEventsResponse, error) {
	rsp, err := c.MachinesListEvents(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListEventsResponse(rsp)
}

// MachinesExecWithBodyWithResponse request with arbitrary body returning *MachinesExecResponse
func (c *ClientWithResponses) MachinesExecWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error) {
	rsp, err := c.MachinesExecWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesExecResponse(rsp)
}

func (c *ClientWithResponses) MachinesExecWithResponse(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error) {
	rsp, err := c.MachinesExec(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesExecResponse(rsp)
}

// MachinesReleaseLeaseWithResponse request returning *MachinesReleaseLeaseResponse
func (c *ClientWithResponses) MachinesReleaseLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*MachinesReleaseLeaseResponse, error) {
	rsp, err := c.MachinesReleaseLease(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesReleaseLeaseResponse(rsp)
}

// MachinesShowLeaseWithResponse request returning *MachinesShowLeaseResponse
func (c *ClientWithResponses) MachinesShowLeaseWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowLeaseResponse, error) {
	rsp, err := c.MachinesShowLease(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowLeaseResponse(rsp)
}

// MachinesCreateLeaseWithBodyWithResponse request with arbitrary body returning *MachinesCreateLeaseResponse
func (c *ClientWithResponses) MachinesCreateLeaseWithBodyWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error) {
	rsp, err := c.MachinesCreateLeaseWithBody(ctx, appName, machineId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateLeaseResponse(rsp)
}

func (c *ClientWithResponses) MachinesCreateLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error) {
	rsp, err := c.MachinesCreateLease(ctx, appName, machineId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateLeaseResponse(rsp)
}

// MachinesShowMetadataWithResponse request returning *MachinesShowMetadataResponse
func (c *ClientWithResponses) MachinesShowMetadataWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowMetadataResponse, error) {
	rsp, err := c.MachinesShowMetadata(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowMetadataResponse(rsp)
}

// MachinesDeleteMetadataWithResponse request returning *MachinesDeleteMetadataResponse
func (c *ClientWithResponses) MachinesDeleteMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesDeleteMetadataResponse, error) {
	rsp, err := c.MachinesDeleteMetadata(ctx, appName, machineId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesDeleteMetadataResponse(rsp)
}

// MachinesUpdateMetadataWithResponse request returning *MachinesUpdateMetadataResponse
func (c *ClientWithResponses) MachinesUpdateMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesUpdateMetadataResponse, error) {
	rsp, err := c.MachinesUpdateMetadata(ctx, appName, machineId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateMetadataResponse(rsp)
}

// MachinesListProcessesWithResponse request returning *MachinesListProcessesResponse
func (c *ClientWithResponses) MachinesListProcessesWithResponse(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*MachinesListProcessesResponse, error) {
	rsp, err := c.MachinesListProcesses(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListProcessesResponse(rsp)
}

// MachinesRestartWithResponse request returning *MachinesRestartResponse
func (c *ClientWithResponses) MachinesRestartWithResponse(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error) {
	rsp, err := c.MachinesRestart(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesRestartResponse(rsp)
}

// MachinesSignalWithBodyWithResponse request with arbitrary body returning *MachinesSignalResponse
func (c *ClientWithResponses) MachinesSignalWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error) {
	rsp, err := c.MachinesSignalWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSignalResponse(rsp)
}

func (c *ClientWithResponses) MachinesSignalWithResponse(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error) {
	rsp, err := c.MachinesSignal(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSignalResponse(rsp)
}

// MachinesStartWithResponse request returning *MachinesStartResponse
func (c *ClientWithResponses) MachinesStartWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error) {
	rsp, err := c.MachinesStart(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStartResponse(rsp)
}

// MachinesStopWithBodyWithResponse request with arbitrary body returning *MachinesStopResponse
func (c *ClientWithResponses) MachinesStopWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error) {
	rsp, err := c.MachinesStopWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStopResponse(rsp)
}

func (c *ClientWithResponses) MachinesStopWithResponse(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error) {
	rsp, err := c.MachinesStop(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStopResponse(rsp)
}

// MachinesSuspendWithResponse request returning *MachinesSuspendResponse
func (c *ClientWithResponses) MachinesSuspendWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesSuspendResponse, error) {
	rsp, err := c.MachinesSuspend(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSuspendResponse(rsp)
}

// MachinesUncordonWithResponse request returning *MachinesUncordonResponse
func (c *ClientWithResponses) MachinesUncordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesUncordonResponse, error) {
	rsp, err := c.MachinesUncordon(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUncordonResponse(rsp)
}

// MachinesListVersionsWithResponse request returning *MachinesListVersionsResponse
func (c *ClientWithResponses) MachinesListVersionsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListVersionsResponse, error) {
	rsp, err := c.MachinesListVersions(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListVersionsResponse(rsp)
}

// MachinesWaitWithResponse request returning *MachinesWaitResponse
func (c *ClientWithResponses) MachinesWaitWithResponse(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*MachinesWaitResponse, error) {
	rsp, err := c.MachinesWait(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesWaitResponse(rsp)
}

// SecretsListWithResponse request returning *SecretsListResponse
func (c *ClientWithResponses) SecretsListWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*SecretsListResponse, error) {
	rsp, err := c.SecretsList(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretsListResponse(rsp)
}

// VolumesListWithResponse request returning *VolumesListResponse
func (c *ClientWithResponses) VolumesListWithResponse(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*VolumesListResponse, error) {
	rsp, err := c.VolumesList(ctx, appName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesListResponse(rsp)
}

// VolumesCreateWithBodyWithResponse request with arbitrary body returning *VolumesCreateResponse
func (c *ClientWithResponses) VolumesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error) {
	rsp, err := c.VolumesCreateWithBody(ctx, appName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesCreateResponse(rsp)
}

func (c *ClientWithResponses) VolumesCreateWithResponse(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error) {
	rsp, err := c.VolumesCreate(ctx, appName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesCreateResponse(rsp)
}

// VolumeDeleteWithResponse request returning *VolumeDeleteResponse
func (c *ClientWithResponses) VolumeDeleteWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumeDeleteResponse, error) {
	rsp, err := c.VolumeDelete(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumeDeleteResponse(rsp)
}

// VolumesGetByIdWithResponse request returning *VolumesGetByIdResponse
func (c *ClientWithResponses) VolumesGetByIdWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesGetByIdResponse, error) {
	rsp, err := c.VolumesGetById(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesGetByIdResponse(rsp)
}

// VolumesUpdateWithBodyWithResponse request with arbitrary body returning *VolumesUpdateResponse
func (c *ClientWithResponses) VolumesUpdateWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error) {
	rsp, err := c.VolumesUpdateWithBody(ctx, appName, volumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesUpdateResponse(rsp)
}

func (c *ClientWithResponses) VolumesUpdateWithResponse(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error) {
	rsp, err := c.VolumesUpdate(ctx, appName, volumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesUpdateResponse(rsp)
}

// VolumesExtendWithBodyWithResponse request with arbitrary body returning *VolumesExtendResponse
func (c *ClientWithResponses) VolumesExtendWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error) {
	rsp, err := c.VolumesExtendWithBody(ctx, appName, volumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesExtendResponse(rsp)
}

func (c *ClientWithResponses) VolumesExtendWithResponse(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error) {
	rsp, err := c.VolumesExtend(ctx, appName, volumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesExtendResponse(rsp)
}

// VolumesListSnapshotsWithResponse request returning *VolumesListSnapshotsResponse
func (c *ClientWithResponses) VolumesListSnapshotsWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesListSnapshotsResponse, error) {
	rsp, err := c.VolumesListSnapshots(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesListSnapshotsResponse(rsp)
}

// CreateVolumeSnapshotWithResponse request returning *CreateVolumeSnapshotResponse
func (c *ClientWithResponses) CreateVolumeSnapshotWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotResponse, error) {
	rsp, err := c.CreateVolumeSnapshot(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeSnapshotResponse(rsp)
}

// TokensRequestKmsWithResponse request returning *TokensRequestKmsResponse
func (c *ClientWithResponses) TokensRequestKmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokensRequestKmsResponse, error) {
	rsp, err := c.TokensRequestKms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestKmsResponse(rsp)
}

// TokensRequestOIDCWithBodyWithResponse request with arbitrary body returning *TokensRequestOIDCResponse
func (c *ClientWithResponses) TokensRequestOIDCWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error) {
	rsp, err := c.TokensRequestOIDCWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestOIDCResponse(rsp)
}

func (c *ClientWithResponses) TokensRequestOIDCWithResponse(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error) {
	rsp, err := c.TokensRequestOIDC(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestOIDCResponse(rsp)
}

// ParseAppsListResponse parses an HTTP response from a AppsListWithResponse call
func ParseAppsListResponse(rsp *http.Response) (*AppsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppsCreateResponse parses an HTTP response from a AppsCreateWithResponse call
func ParseAppsCreateResponse(rsp *http.Response) (*AppsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAppsDeleteResponse parses an HTTP response from a AppsDeleteWithResponse call
func ParseAppsDeleteResponse(rsp *http.Response) (*AppsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppsShowResponse parses an HTTP response from a AppsShowWithResponse call
func ParseAppsShowResponse(rsp *http.Response) (*AppsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesListResponse parses an HTTP response from a MachinesListWithResponse call
func ParseMachinesListResponse(rsp *http.Response) (*MachinesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesCreateResponse parses an HTTP response from a MachinesCreateWithResponse call
func ParseMachinesCreateResponse(rsp *http.Response) (*MachinesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesDeleteResponse parses an HTTP response from a MachinesDeleteWithResponse call
func ParseMachinesDeleteResponse(rsp *http.Response) (*MachinesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesShowResponse parses an HTTP response from a MachinesShowWithResponse call
func ParseMachinesShowResponse(rsp *http.Response) (*MachinesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesUpdateResponse parses an HTTP response from a MachinesUpdateWithResponse call
func ParseMachinesUpdateResponse(rsp *http.Response) (*MachinesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesCordonResponse parses an HTTP response from a MachinesCordonWithResponse call
func ParseMachinesCordonResponse(rsp *http.Response) (*MachinesCordonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCordonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesListEventsResponse parses an HTTP response from a MachinesListEventsWithResponse call
func ParseMachinesListEventsResponse(rsp *http.Response) (*MachinesListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MachineEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesExecResponse parses an HTTP response from a MachinesExecWithResponse call
func ParseMachinesExecResponse(rsp *http.Response) (*MachinesExecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesExecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flydv1ExecResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/octet-stream) unsupported

	case rsp.StatusCode == 400:
		// Content-type (application/octet-stream) unsupported

	}

	return response, nil
}

// ParseMachinesReleaseLeaseResponse parses an HTTP response from a MachinesReleaseLeaseWithResponse call
func ParseMachinesReleaseLeaseResponse(rsp *http.Response) (*MachinesReleaseLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesReleaseLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesShowLeaseResponse parses an HTTP response from a MachinesShowLeaseWithResponse call
func ParseMachinesShowLeaseResponse(rsp *http.Response) (*MachinesShowLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesCreateLeaseResponse parses an HTTP response from a MachinesCreateLeaseWithResponse call
func ParseMachinesCreateLeaseResponse(rsp *http.Response) (*MachinesCreateLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCreateLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesShowMetadataResponse parses an HTTP response from a MachinesShowMetadataWithResponse call
func ParseMachinesShowMetadataResponse(rsp *http.Response) (*MachinesShowMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesDeleteMetadataResponse parses an HTTP response from a MachinesDeleteMetadataWithResponse call
func ParseMachinesDeleteMetadataResponse(rsp *http.Response) (*MachinesDeleteMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesDeleteMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesUpdateMetadataResponse parses an HTTP response from a MachinesUpdateMetadataWithResponse call
func ParseMachinesUpdateMetadataResponse(rsp *http.Response) (*MachinesUpdateMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUpdateMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesListProcessesResponse parses an HTTP response from a MachinesListProcessesWithResponse call
func ParseMachinesListProcessesResponse(rsp *http.Response) (*MachinesListProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProcessStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesRestartResponse parses an HTTP response from a MachinesRestartWithResponse call
func ParseMachinesRestartResponse(rsp *http.Response) (*MachinesRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesSignalResponse parses an HTTP response from a MachinesSignalWithResponse call
func ParseMachinesSignalResponse(rsp *http.Response) (*MachinesSignalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesSignalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesStartResponse parses an HTTP response from a MachinesStartWithResponse call
func ParseMachinesStartResponse(rsp *http.Response) (*MachinesStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesStopResponse parses an HTTP response from a MachinesStopWithResponse call
func ParseMachinesStopResponse(rsp *http.Response) (*MachinesStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesSuspendResponse parses an HTTP response from a MachinesSuspendWithResponse call
func ParseMachinesSuspendResponse(rsp *http.Response) (*MachinesSuspendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesSuspendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesUncordonResponse parses an HTTP response from a MachinesUncordonWithResponse call
func ParseMachinesUncordonResponse(rsp *http.Response) (*MachinesUncordonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUncordonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesListVersionsResponse parses an HTTP response from a MachinesListVersionsWithResponse call
func ParseMachinesListVersionsResponse(rsp *http.Response) (*MachinesListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MachineVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesWaitResponse parses an HTTP response from a MachinesWaitWithResponse call
func ParseMachinesWaitResponse(rsp *http.Response) (*MachinesWaitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesWaitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSecretsListResponse parses an HTTP response from a SecretsListWithResponse call
func ParseSecretsListResponse(rsp *http.Response) (*SecretsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesListResponse parses an HTTP response from a VolumesListWithResponse call
func ParseVolumesListResponse(rsp *http.Response) (*VolumesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesCreateResponse parses an HTTP response from a VolumesCreateWithResponse call
func ParseVolumesCreateResponse(rsp *http.Response) (*VolumesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumeDeleteResponse parses an HTTP response from a VolumeDeleteWithResponse call
func ParseVolumeDeleteResponse(rsp *http.Response) (*VolumeDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumeDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesGetByIdResponse parses an HTTP response from a VolumesGetByIdWithResponse call
func ParseVolumesGetByIdResponse(rsp *http.Response) (*VolumesGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesUpdateResponse parses an HTTP response from a VolumesUpdateWithResponse call
func ParseVolumesUpdateResponse(rsp *http.Response) (*VolumesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseVolumesExtendResponse parses an HTTP response from a VolumesExtendWithResponse call
func ParseVolumesExtendResponse(rsp *http.Response) (*VolumesExtendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesExtendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtendVolumeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesListSnapshotsResponse parses an HTTP response from a VolumesListSnapshotsWithResponse call
func ParseVolumesListSnapshotsResponse(rsp *http.Response) (*VolumesListSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesListSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VolumeSnapshot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeSnapshotResponse parses an HTTP response from a CreateVolumeSnapshotWithResponse call
func ParseCreateVolumeSnapshotResponse(rsp *http.Response) (*CreateVolumeSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTokensRequestKmsResponse parses an HTTP response from a TokensRequestKmsWithResponse call
func ParseTokensRequestKmsResponse(rsp *http.Response) (*TokensRequestKmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokensRequestKmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTokensRequestOIDCResponse parses an HTTP response from a TokensRequestOIDCWithResponse call
func ParseTokensRequestOIDCResponse(rsp *http.Response) (*TokensRequestOIDCResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokensRequestOIDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

